import numpy as np


def BiotSavart(Coil_Trace, Current, Points_Pos):
    """
    Optimized calculation of the magnetic field generated by a current-carrying coil
    at specified spatial points using the Biot-Savart Law.
    """
    mu0 = 4 * np.pi * 1e-7  # Permeability of free space (T·m/A)

    # Compute segment midpoints and differences
    Coil_Trace_Center = (Coil_Trace[:-1] + Coil_Trace[1:]) * 0.5
    dL = Coil_Trace[1:] - Coil_Trace[:-1]

    # Compute relative positions between points and coil segment centers
    R = Points_Pos[:, np.newaxis, :] - Coil_Trace_Center[np.newaxis, :, :]

    # Compute distances and avoid division by zero
    Distance_Cube = np.sum(R**2, axis=-1)**1.5 + 1e-15

    # Compute cross products efficiently
    dB = np.cross(dL, R, axis=-1) / Distance_Cube[..., np.newaxis]

    # Sum contributions from all segments and scale by constants
    B = mu0 * Current * np.sum(dB, axis=1) / (4 * np.pi)

    return B


def BiotSavartTorch(Coil_Trace, Current, Points_Pos, device='cuda', low_memory=False, batch_size=None):
    """
    Torch implementation of the Biot-Savart Law for GPU acceleration with an optional low-memory mode.

    Parameters:
    Coil_Trace : torch.Tensor, shape [n_nodes, 3], dtype=torch.float32
        3D coordinate trace of the coil, where each node contains (x, y, z) coordinates.
    Current : float
        Electric current flowing through the coil.
    Points_Pos : torch.Tensor, shape [n_points, 3], dtype=torch.float32
        Coordinates of spatial points where the magnetic field needs to be calculated.
    device : str
        Device to perform computation on ('cuda' for GPU, 'cpu' for CPU).
    low_memory : bool
        If True, enables low-memory mode by processing Points_Pos in smaller batches.
    batch_size : int or None
        Number of points to process in each batch. If None, it will be auto-calculated based on available memory.

    Returns:
    B : torch.Tensor, shape [n_points, 3], dtype=torch.float32
        Magnetic field vector (Bx, By, Bz) at each spatial point.
    """
    import torch
    from tqdm import tqdm

    # Move data to the specified device
    Coil_Trace = Coil_Trace.to(device)
    Points_Pos = Points_Pos.to(device)
    mu0 = 4 * torch.pi * 1e-7  # Permeability of free space (T·m/A)

    # Compute segment midpoints and differences
    Coil_Trace_Center = (Coil_Trace[:-1] + Coil_Trace[1:]) * 0.5
    dL = (Coil_Trace[1:] - Coil_Trace[:-1]).unsqueeze(0)

    # Initialize the output tensor
    n_points = Points_Pos.shape[0]
    B = torch.zeros((n_points, 3), device=device, dtype=torch.float32)

    if low_memory:
        # Determine batch size if not provided
        if batch_size is None:
            # Estimate batch size based on available memory (adjust as needed)
            batch_size = 1000  # Default batch size (can be tuned)

        # Process Points_Pos in batches
        for start_idx in tqdm(range(0, n_points, batch_size)):
            end_idx = min(start_idx + batch_size, n_points)
            batch_points = Points_Pos[start_idx:end_idx]

            # Compute relative positions and distances for the batch
            R = batch_points[:, None, :] - Coil_Trace_Center[None, :, :]
            Distance_Cube = torch.sum(R**2, dim=-1)**1.5 + 1e-15
            dB = torch.cross(dL, R, dim=-1) / Distance_Cube[..., None]

            # Sum contributions and store in the output tensor
            B[start_idx:end_idx] = mu0 * Current * \
                torch.sum(dB, dim=1) / (4 * torch.pi)
    else:
        # Full computation without batching
        R = Points_Pos[:, None, :] - Coil_Trace_Center[None, :, :]
        Distance_Cube = torch.sum(R**2, dim=-1)**1.5 + 1e-15
        dB = torch.cross(dL, R, dim=-1) / Distance_Cube[..., None]
        B = mu0 * Current * torch.sum(dB, dim=1) / (4 * torch.pi)

    return B
